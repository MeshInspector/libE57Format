/*
 * Original work Copyright 2009 - 2010 Kevin Ackley (kackley@gwi.net)
 * Modified work Copyright 2018 - 2020 Andy Maloney <asmaloney@gmail.com>
 *
 * Permission is hereby granted, free of charge, to any person or organization
 * obtaining a copy of the software and accompanying documentation covered by
 * this license (the "Software") to use, reproduce, display, distribute,
 * execute, and transmit the Software, and to prepare derivative works of the
 * Software, and to permit third-parties to whom the Software is furnished to
 * do so, all subject to the following:
 *
 * The copyright notices in the Software and this entire statement, including
 * the above license grant, this restriction and the following disclaimer,
 * must be included in all copies of the Software, in whole or in part, and
 * all derivative works of the Software, unless such copies or derivative
 * works are solely in the form of machine-executable object code generated by
 * a source language processor.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
 * SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
 * FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 */

#include <codecvt>
#include <string>

#include <expat.h>

#include "E57XmlParser.h"
#include "ImageFileImpl.h"
#include "StringFunctions.h"

using namespace e57;

namespace
{
#ifdef XML_UNICODE
   static_assert( sizeof( XML_Char ) == sizeof( char16_t ),
                  "only 16-bit unicode chars are supported" );

   ustring toUString( const XML_Char *xml_str, size_t len = 0 )
   {
      const auto *u16_str = reinterpret_cast<const char16_t *>( xml_str );
      if ( u16_str == NULL || *u16_str == u'\0' )
      {
         return {};
      }

      if ( len == 0 )
      {
         len = std::char_traits<char16_t>::length( u16_str );
      }

      std::wstring_convert<std::codecvt_utf8_utf16<char16_t>, char16_t> converter;
      return converter.to_bytes( u16_str, u16_str + len );
   }
#else
   ustring toUString( const XML_Char *xml_str, size_t len = 0 )
   {
      if ( xml_str == NULL || *xml_str == '\0' )
      {
         return {};
      }

      if ( len == 0 )
      {
         len = std::char_traits<XML_Char>::length( xml_str );
      }

      return { xml_str, len };
   }
#endif

   /// character used to split an element name into uri, local name, and prefix parts
#ifdef E57_VERBOSE
   constexpr char expatNamespaceSeparator = '&'; /// visible character for debug purposes
#else
   constexpr char expatNamespaceSeparator = '\x1f';
#endif

   struct ElementName
   {
      ustring uri;
      ustring localName;
      ustring prefix;

      /// represent the element name in the fully qualified name format "prefix:name"
      ustring qName() const
      {
         return prefix.empty() ? localName : prefix + ":" + localName;
      }

      /// split an element name into parts
      static ElementName fromRawName( const ustring &name )
      {
         const auto sep1 = name.find( expatNamespaceSeparator );
         const auto sep2 = name.find_last_of( expatNamespaceSeparator );
         if ( sep1 == ustring::npos )
         {
            return { "", name, "" };
         }
         else if ( sep2 == sep1 )
         {
            return { name.substr( 0, sep1 ), name.substr( sep1 + 1 ), "" };
         }
         else
         {
            return { name.substr( 0, sep1 ), name.substr( sep1 + 1, sep2 - sep1 - 1 ),
                     name.substr( sep2 + 1 ) };
         }
      }

#ifdef E57_VERBOSE
      ustring getContext() const
      {
         return "uri=" + uri + ", localName=" + localName + ", prefix=" + prefix;
      }
#endif
   };
}

//=============================================================================
// E57XmlProcessor::AttributeMap

class AttributeMap final : public E57XmlProcessor::AttributeMap
{
public:
   explicit AttributeMap( const XML_Char **attributes );
   ~AttributeMap() override = default;

   size_t length() const override;
   ustring getQName( size_t index ) const override;
   ustring getValue( size_t index ) const override;

   bool contains( const ustring &name ) const override;
   ustring lookup( const ustring &name ) const override;

private:
   const XML_Char **attributes_;
   std::map<ustring, const XML_Char *> map_;
};

AttributeMap::AttributeMap( const XML_Char **attributes ) : attributes_( attributes )
{
   // cache attribute names to speed up the lookup and to avoid converting on every call
   for ( const auto **attrPair = attributes; *attrPair != nullptr; attrPair += 2 )
   {
      const auto attrName = ElementName::fromRawName( toUString( attrPair[0] ) );
      map_.emplace( attrName.qName(), attrPair[1] );
   }
}

size_t AttributeMap::length() const
{
   return map_.size();
}

ustring AttributeMap::getQName( size_t index ) const
{
   const auto *attrPair = attributes_ + 2 * index;
   return attrPair[0];
}

ustring AttributeMap::getValue( size_t index ) const
{
   const auto *attrPair = attributes_ + 2 * index;
   return attrPair[1];
}

bool AttributeMap::contains( const ustring &name ) const
{
   return map_.find( name ) != map_.end();
}

ustring AttributeMap::lookup( const ustring &name ) const
{
   const auto it = map_.find( name );
   if ( it == map_.end() )
   {
      throw E57_EXCEPTION2( ErrorBadXMLFormat, "attributeName=" + name );
   }
   return toUString( it->second );
}

//=============================================================================
// E57XmlParserImpl

class Parser final : public E57XmlParserImpl
{
public:
   ~Parser() override;

   void init() override;

   void parse( E57XmlInputSource &inputSource, E57XmlProcessor &processor ) override;

private:
   friend void XMLCALL startNamespaceDeclHandler( void *userData, const XML_Char *prefix,
                                                  const XML_Char *uri );
   friend void XMLCALL startElementHandler( void *userData, const XML_Char *name,
                                            const XML_Char **attrs );
   friend void XMLCALL endElementHandler( void *userData, const XML_Char *name );
   friend void XMLCALL characterDataHandler( void *userData, const XML_Char *s, int len );

   XML_Parser parser_{ nullptr };
};

void XMLCALL startNamespaceDeclHandler( void *userData, const XML_Char *prefix,
                                        const XML_Char *uri )
{
   auto *processor = reinterpret_cast<E57XmlProcessor *>( userData );
   processor->startNamespace( toUString( prefix ), toUString( uri ) );
}

void XMLCALL startElementHandler( void *userData, const XML_Char *name, const XML_Char **attrs )
{
   auto *processor = reinterpret_cast<E57XmlProcessor *>( userData );
   const auto element = ElementName::fromRawName( toUString( name ) );
   const auto attrMap = AttributeMap( attrs );
   processor->startElement( element.qName(), attrMap );
}

void XMLCALL endElementHandler( void *userData, const XML_Char *name )
{
   auto *processor = reinterpret_cast<E57XmlProcessor *>( userData );
   const auto element = ElementName::fromRawName( toUString( name ) );
   processor->endElement( element.qName() );
}

void XMLCALL characterDataHandler( void *userData, const XML_Char *s, int len )
{
   auto *processor = reinterpret_cast<E57XmlProcessor *>( userData );
   processor->text( toUString( s, len ) );
}

Parser::~Parser()
{
   if ( parser_ )
   {
      XML_ParserFree( parser_ );
   }
}

void Parser::init()
{
   parser_ = XML_ParserCreateNS( nullptr, expatNamespaceSeparator );
   if ( parser_ == nullptr )
   {
      throw E57_EXCEPTION2( ErrorXMLParserInit, "could not create the xml reader" );
   }

   XML_SetElementHandler( parser_, startElementHandler, endElementHandler );
   XML_SetCharacterDataHandler( parser_, characterDataHandler );
   XML_SetStartNamespaceDeclHandler( parser_, startNamespaceDeclHandler );
   // add prefix to the element name
   XML_SetReturnNSTriplet( parser_, 1 );
}

void Parser::parse( E57XmlInputSource &inputSource, E57XmlProcessor &processor )
{
   XML_SetUserData( parser_, &processor );

   bool done = false;
   while ( !done )
   {
      auto *buffer = XML_GetBuffer( parser_, BUFSIZ );
      if ( buffer == nullptr )
      {
         throw E57_EXCEPTION2( ErrorXMLParser, "failed to allocate memory" );
      }

      auto len = inputSource.readBytes( (unsigned char *)buffer, BUFSIZ );
      done = ( len == 0 );
      switch ( XML_ParseBuffer( parser_, (int)len, done ) )
      {
         case XML_STATUS_ERROR:
         {
            const auto errorCode = XML_GetErrorCode( parser_ );
            const auto *errorString = XML_ErrorString( errorCode );
            const auto offset = XML_GetCurrentByteIndex( parser_ );
            const auto line = XML_GetCurrentLineNumber( parser_ );
            const auto column = XML_GetCurrentColumnNumber( parser_ );
            throw E57_EXCEPTION2(
               ErrorXMLParser, "errorCode=" + toString( errorCode ) + ", errorString=\"" +
                                  toUString( errorString ) + "\", offset=" + toString( offset ) +
                                  ", line=" + toString( line ) + ", column=" + toString( column ) );
         }
         case XML_STATUS_OK:
            break;
         case XML_STATUS_SUSPENDED:
            throw E57_EXCEPTION2( ErrorXMLParser, "unexpected parse suspension" );
      }
   }
}

//=============================================================================
// E57XmlParserImpl

std::unique_ptr<E57XmlParserImpl> E57XmlParserImpl::create()
{
   return std::make_unique<Parser>();
}
