/*
 * Original work Copyright 2009 - 2010 Kevin Ackley (kackley@gwi.net)
 * Modified work Copyright 2018 - 2020 Andy Maloney <asmaloney@gmail.com>
 *
 * Permission is hereby granted, free of charge, to any person or organization
 * obtaining a copy of the software and accompanying documentation covered by
 * this license (the "Software") to use, reproduce, display, distribute,
 * execute, and transmit the Software, and to prepare derivative works of the
 * Software, and to permit third-parties to whom the Software is furnished to
 * do so, all subject to the following:
 *
 * The copyright notices in the Software and this entire statement, including
 * the above license grant, this restriction and the following disclaimer,
 * must be included in all copies of the Software, in whole or in part, and
 * all derivative works of the Software, unless such copies or derivative
 * works are solely in the form of machine-executable object code generated by
 * a source language processor.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
 * SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
 * FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 */

#include <codecvt>
#include <string>

#include <expat.h>

#include "E57XmlParser.h"
#include "ImageFileImpl.h"
#include "StringFunctions.h"

using namespace e57;

namespace
{
#ifdef XML_UNICODE
   static_assert( sizeof( XML_Char ) == sizeof( char16_t ),
                  "only 16-bit unicode chars are supported" );

   ustring toUString( const XML_Char *xml_str, size_t len = 0 )
   {
      const auto *u16_str = reinterpret_cast<const char16_t *>( xml_str );
      if ( u16_str == NULL || *u16_str == u'\0' )
      {
         return {};
      }

      if ( len == 0 )
      {
         len = std::char_traits<char16_t>::length( u16_str );
      }

      std::wstring_convert<std::codecvt_utf8_utf16<char16_t>, char16_t> converter;
      return converter.to_bytes( u16_str, u16_str + len );
   }
#else
   ustring toUString( const XML_Char *xml_str, size_t len = 0 )
   {
      if ( xml_str == NULL || *xml_str == '\0' )
      {
         return {};
      }

      if ( len == 0 )
      {
         len = std::char_traits<XML_Char>::length( xml_str );
      }

      return { xml_str, len };
   }
#endif

   /// character used to split an element name into uri, local name, and prefix parts
#ifdef E57_VERBOSE
   constexpr char expatNamespaceSeparator = '&'; /// visible character for debug purposes
#else
   constexpr char expatNamespaceSeparator = '\x1f';
#endif

   struct ElementName
   {
      ustring uri;
      ustring localName;
      ustring prefix;

      /// represent the element name in the fully qualified name format "prefix:name"
      ustring qName() const
      {
         return prefix.empty() ? localName : prefix + ":" + localName;
      }

      /// split an element name into parts
      static ElementName fromRawName( const ustring &name )
      {
         const auto sep1 = name.find( expatNamespaceSeparator );
         const auto sep2 = name.find_last_of( expatNamespaceSeparator );
         if ( sep1 == ustring::npos )
         {
            return { "", name, "" };
         }
         else if ( sep2 == sep1 )
         {
            return { name.substr( 0, sep1 ), name.substr( sep1 + 1 ), "" };
         }
         else
         {
            return { name.substr( 0, sep1 ), name.substr( sep1 + 1, sep2 - sep1 - 1 ),
                     name.substr( sep2 + 1 ) };
         }
      }

#ifdef E57_VERBOSE
      ustring getContext() const
      {
         return "uri=" + uri + ", localName=" + localName + ", prefix=" + prefix;
      }
#endif
   };
}

//=============================================================================
// E57XmlParserImpl::AttributeMap

class AttributeMapImplExpat final : public E57XmlParserImpl::AttributeMap
{
public:
   explicit AttributeMapImplExpat( const XML_Char **attributes );
   ~AttributeMapImplExpat() override = default;

   bool contains( const ustring &name ) const override;
   ustring lookup( const ustring &name ) const override;

private:
   std::map<ustring, const XML_Char *> attributes_;
};

AttributeMapImplExpat::AttributeMapImplExpat( const XML_Char **attributes )
{
   // cache attribute names to speed up the lookup and to avoid converting on every call
   for ( const auto **attrPair = attributes; *attrPair != nullptr; attrPair += 2 )
   {
      const auto attrName = ElementName::fromRawName( toUString( attrPair[0] ) );
      attributes_.emplace( attrName.qName(), attrPair[1] );
   }
}

bool AttributeMapImplExpat::contains( const ustring &name ) const
{
   return attributes_.find( name ) != attributes_.end();
}

ustring AttributeMapImplExpat::lookup( const ustring &name ) const
{
   const auto it = attributes_.find( name );
   if ( it == attributes_.end() )
   {
      throw E57_EXCEPTION2( ErrorBadXMLFormat, "attributeName=" + name );
   }
   return toUString( it->second );
}

//=============================================================================
// E57XmlParserImplExpat

class E57XmlParserImplExpat final : public E57XmlParserImpl
{
public:
   ~E57XmlParserImplExpat() override;

   void init() override;

   void parse( ImageFileImplSharedPtr imf, E57XmlInputSource &inputSource ) override;

protected:
   ustring getContext() const override;

private:
   friend void XMLCALL startNamespaceDeclHandler( void *userData, const XML_Char *prefix,
                                                  const XML_Char *uri );
   friend void XMLCALL startElementHandler( void *userData, const XML_Char *name,
                                            const XML_Char **attrs );
   friend void XMLCALL endElementHandler( void *userData, const XML_Char *name );
   friend void XMLCALL characterDataHandler( void *userData, const XML_Char *s, int len );

   XML_Parser parser_{ nullptr };
   ElementName curElem_;
};

void XMLCALL startNamespaceDeclHandler( void *userData, const XML_Char *prefix,
                                        const XML_Char *uri )
{
#ifdef E57_VERBOSE
   std::cout << "startNamespaceDecl, prefix=" + toUString( prefix ) + " URI=" + toUString( uri )
             << std::endl;
#endif

   auto *impl = reinterpret_cast<E57XmlParserImplExpat *>( userData );
   impl->startNamespace_( toUString( prefix ), toUString( uri ) );
}

void XMLCALL startElementHandler( void *userData, const XML_Char *name, const XML_Char **attrs )
{
   auto *impl = reinterpret_cast<E57XmlParserImplExpat *>( userData );
   auto &curElem = impl->curElem_;
   curElem = ElementName::fromRawName( toUString( name ) );

#ifdef E57_VERBOSE
   std::cout << "startElement" << std::endl;
   std::cout << space( 2 ) << "URI:       " << curElem.uri << std::endl;
   std::cout << space( 2 ) << "localName: " << curElem.localName << std::endl;
   std::cout << space( 2 ) << "qName:     " << curElem.qName() << std::endl;

   int i = 0;
   for ( const auto **attrPair = attrs; *attrPair != nullptr; attrPair += 2 )
   {
      const auto attrName = ElementName::fromRawName( toUString( attrPair[0] ) );
      std::cout << space( 2 ) << "Attribute[" << i << "]" << std::endl;
      std::cout << space( 4 ) << "URI:       " << attrName.uri << std::endl;
      std::cout << space( 4 ) << "localName: " << attrName.localName << std::endl;
      std::cout << space( 4 ) << "qName:     " << attrName.qName() << std::endl;
      std::cout << space( 4 ) << "value:     " << toUString( attrPair[1] ) << std::endl;
   }
#endif

   AttributeMapImplExpat attrMap( attrs );
   impl->startElement_( curElem.qName(), attrMap );
}

void XMLCALL endElementHandler( void *userData, const XML_Char *name )
{
#ifdef E57_VERBOSE
   std::cout << "endElement" << std::endl;
#endif

   auto *impl = reinterpret_cast<E57XmlParserImplExpat *>( userData );
   auto &curElem = impl->curElem_;
   curElem = ElementName::fromRawName( toUString( name ) );

   impl->endElement_( curElem.qName() );
}

void XMLCALL characterDataHandler( void *userData, const XML_Char *s, int len )
{
#ifdef E57_VERBOSE
   std::cout << "characterData, chars=\"" << toUString( s, len ) << "\" length=" << len
             << std::endl;
#endif

   auto *impl = reinterpret_cast<E57XmlParserImplExpat *>( userData );
   impl->characters_( toUString( s, len ) );
}

E57XmlParserImplExpat::~E57XmlParserImplExpat()
{
   if ( parser_ )
   {
      XML_ParserFree( parser_ );
   }
}

void E57XmlParserImplExpat::init()
{
   parser_ = XML_ParserCreateNS( nullptr, expatNamespaceSeparator );
   if ( parser_ == nullptr )
   {
      throw E57_EXCEPTION2( ErrorXMLParserInit, "could not create the xml reader" );
   }

   XML_SetUserData( parser_, this );
   XML_SetElementHandler( parser_, startElementHandler, endElementHandler );
   XML_SetCharacterDataHandler( parser_, characterDataHandler );
   XML_SetStartNamespaceDeclHandler( parser_, startNamespaceDeclHandler );
   // add prefix to the element name
   XML_SetReturnNSTriplet( parser_, 1 );
}

void E57XmlParserImplExpat::parse( ImageFileImplSharedPtr imf, E57XmlInputSource &inputSource )
{
   imf_ = std::move( imf );

   bool done = false;
   while ( !done )
   {
      auto *buffer = XML_GetBuffer( parser_, BUFSIZ );
      if ( buffer == nullptr )
      {
         throw E57_EXCEPTION2( ErrorXMLParser, "failed to allocate memory" );
      }

      auto len = inputSource.readBytes( (unsigned char *)buffer, BUFSIZ );
      done = ( len == 0 );
      switch ( XML_ParseBuffer( parser_, (int)len, done ) )
      {
         case XML_STATUS_ERROR:
         {
            const auto errorCode = XML_GetErrorCode( parser_ );
            const auto *errorString = XML_ErrorString( errorCode );
            const auto offset = XML_GetCurrentByteIndex( parser_ );
            const auto line = XML_GetCurrentLineNumber( parser_ );
            const auto column = XML_GetCurrentColumnNumber( parser_ );
            throw E57_EXCEPTION2(
               ErrorXMLParser, "errorCode=" + toString( errorCode ) + ", errorString=\"" +
                                  toUString( errorString ) + "\", offset=" + toString( offset ) +
                                  ", line=" + toString( line ) + ", column=" + toString( column ) );
         }
         case XML_STATUS_OK:
            break;
         case XML_STATUS_SUSPENDED:
            throw E57_EXCEPTION2( ErrorXMLParser, "unexpected parse suspension" );
      }
   }
}

ustring E57XmlParserImplExpat::getContext() const
{
   return "fileName=" + imf_->fileName() + " uri=" + curElem_.uri +
          " localName=" + curElem_.localName + " qName=" + curElem_.qName();
}

//=============================================================================
// E57XmlParserImpl

std::unique_ptr<E57XmlParserImpl> E57XmlParserImpl::create()
{
   return std::make_unique<E57XmlParserImplExpat>();
}
