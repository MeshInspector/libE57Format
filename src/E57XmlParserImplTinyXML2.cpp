/*
 * Original work Copyright 2009 - 2010 Kevin Ackley (kackley@gwi.net)
 * Modified work Copyright 2018 - 2020 Andy Maloney <asmaloney@gmail.com>
 *
 * Permission is hereby granted, free of charge, to any person or organization
 * obtaining a copy of the software and accompanying documentation covered by
 * this license (the "Software") to use, reproduce, display, distribute,
 * execute, and transmit the Software, and to prepare derivative works of the
 * Software, and to permit third-parties to whom the Software is furnished to
 * do so, all subject to the following:
 *
 * The copyright notices in the Software and this entire statement, including
 * the above license grant, this restriction and the following disclaimer,
 * must be included in all copies of the Software, in whole or in part, and
 * all derivative works of the Software, unless such copies or derivative
 * works are solely in the form of machine-executable object code generated by
 * a source language processor.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
 * SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
 * FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 */

#include <tinyxml2.h>

#include "E57XmlParser.h"
#include "StringFunctions.h"

using namespace e57;
using namespace tinyxml2;

//=============================================================================
// E57XmlProcessor::AttributeMap

class AttributeMap final : public E57XmlProcessor::AttributeMap
{
public:
   explicit AttributeMap( const XMLAttribute *attributes );
   ~AttributeMap() override = default;

   size_t length() const override;
   ustring getQName( size_t index ) const override;
   ustring getValue( size_t index ) const override;

   bool contains( const ustring &name ) const override;
   ustring lookup( const ustring &name ) const override;

private:
   const XMLAttribute *attributes_;
   std::map<ustring, const XMLAttribute *> map_;
};

AttributeMap::AttributeMap( const XMLAttribute *attributes ) : attributes_( attributes )
{
   // cache attribute names to speed up the lookup
   for ( const auto *attr = attributes; attr != NULL; attr = attr->Next() )
   {
      map_.emplace( attr->Name(), attr );
   }
}

size_t AttributeMap::length() const
{
   return map_.size();
}

ustring AttributeMap::getQName( size_t index ) const
{
   const auto &attr = attributes_[index];
   return attr.Name();
}

ustring AttributeMap::getValue( size_t index ) const
{
   const auto &attr = attributes_[index];
   return attr.Value();
}

bool AttributeMap::contains( const ustring &name ) const
{
   return map_.find( name ) != map_.end();
}

ustring AttributeMap::lookup( const ustring &name ) const
{
   const auto it = map_.find( name );
   if ( it == map_.end() )
   {
      throw E57_EXCEPTION2( ErrorBadXMLFormat, "attributeName=" + name );
   }
   return it->second->Value();
}

//=============================================================================
// E57XmlParserImpl

class Parser final : public E57XmlParserImpl, public XMLVisitor
{
public:
   void init() override;

   void parse( E57XmlInputSource &inputSource, E57XmlProcessor &processor ) override;

private:
   bool VisitEnter( const XMLElement &element, const XMLAttribute *attributes ) override;
   bool VisitExit( const XMLElement &element ) override;
   bool Visit( const XMLText &text ) override;

   XMLDocument xmlDocument_;
   E57XmlProcessor *processor_{ nullptr };
};

void Parser::init()
{
}

void Parser::parse( E57XmlInputSource &inputSource, E57XmlProcessor &processor )
{
   std::string buffer( inputSource.length(), ' ' );
   if ( inputSource.readBytes( (unsigned char *)buffer.data(), buffer.size() ) != buffer.size() )
   {
      throw E57_EXCEPTION2( ErrorXMLParser, "failed to read input data" );
   }
   if ( xmlDocument_.Parse( buffer.data(), buffer.size() ) != XML_SUCCESS )
   {
      throw E57_EXCEPTION2( ErrorXMLParser,
                            "errorID=" + toString( xmlDocument_.ErrorID() ) + " errorString=\"" +
                               xmlDocument_.ErrorStr() +
                               "\" line=" + toString( xmlDocument_.ErrorLineNum() ) );
   }

   processor_ = &processor;
   xmlDocument_.Accept( this );
}

bool Parser::VisitEnter( const XMLElement &element, const XMLAttribute *attributes )
{
   // find namespace declarations
   for ( const auto *attr = attributes; attr != NULL; attr = attr->Next() )
   {
      const auto name = ustring( attr->Name() );
      if ( name == "xmlns" )
      {
         processor_->startNamespace( "", attr->Value() );
      }
      else if ( name.substr( 0, 6 ) == "xmlns:" )
      {
         processor_->startNamespace( name.substr( 6 ), attr->Value() );
      }
   }

   const AttributeMap attrMap( attributes );
   processor_->startElement( element.Name(), attrMap );

   return true;
}

bool Parser::VisitExit( const XMLElement &element )
{
   processor_->endElement( element.Name() );

   return true;
}

bool Parser::Visit( const XMLText &text )
{
   processor_->text( text.Value() );

   return true;
}

std::unique_ptr<E57XmlParserImpl> E57XmlParserImpl::create()
{
   return std::make_unique<Parser>();
}
