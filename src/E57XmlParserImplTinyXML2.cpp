/*
 * Original work Copyright 2009 - 2010 Kevin Ackley (kackley@gwi.net)
 * Modified work Copyright 2018 - 2020 Andy Maloney <asmaloney@gmail.com>
 *
 * Permission is hereby granted, free of charge, to any person or organization
 * obtaining a copy of the software and accompanying documentation covered by
 * this license (the "Software") to use, reproduce, display, distribute,
 * execute, and transmit the Software, and to prepare derivative works of the
 * Software, and to permit third-parties to whom the Software is furnished to
 * do so, all subject to the following:
 *
 * The copyright notices in the Software and this entire statement, including
 * the above license grant, this restriction and the following disclaimer,
 * must be included in all copies of the Software, in whole or in part, and
 * all derivative works of the Software, unless such copies or derivative
 * works are solely in the form of machine-executable object code generated by
 * a source language processor.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
 * SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
 * FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 */

#include <tinyxml2.h>

#include "E57XmlParser.h"
#include "ImageFileImpl.h"
#include "StringFunctions.h"

using namespace e57;
using namespace tinyxml2;

//=============================================================================
// E57XmlParserImpl::AttributeMap

class AttributeMapImplTinyXML2 final : public E57XmlParserImpl::AttributeMap
{
public:
   explicit AttributeMapImplTinyXML2( const XMLAttribute *attributes );
   ~AttributeMapImplTinyXML2() override = default;

   bool contains( const ustring &name ) const override;
   ustring lookup( const ustring &name ) const override;

private:
   std::map<ustring, const XMLAttribute *> attributes_;
};

AttributeMapImplTinyXML2::AttributeMapImplTinyXML2( const XMLAttribute *attributes )
{
   // cache attribute names to speed up the lookup
   for ( const auto *attr = attributes; attr != NULL; attr = attr->Next() )
   {
      attributes_.emplace( attr->Name(), attr );
   }
}

bool AttributeMapImplTinyXML2::contains( const ustring &name ) const
{
   return attributes_.find( name ) != attributes_.end();
}

ustring AttributeMapImplTinyXML2::lookup( const ustring &name ) const
{
   const auto it = attributes_.find( name );
   if ( it == attributes_.end() )
   {
      throw E57_EXCEPTION2( ErrorBadXMLFormat, "attributeName=" + name );
   }
   return it->second->Value();
}

//=============================================================================
// E57XmlParserImplExpat

class E57XmlParserImplTinyXML2 final : public E57XmlParserImpl, public XMLVisitor
{
public:
   void init() override;

   void parse( ImageFileImplSharedPtr imf, E57XmlInputSource &inputSource ) override;

protected:
   ustring getContext() const override;

private:
   bool VisitEnter( const XMLElement &element, const XMLAttribute *attributes ) override;
   bool VisitExit( const XMLElement &element ) override;
   bool Visit( const XMLText &text ) override;

   XMLDocument xmlDocument_;
   ustring curElem_;
};

void E57XmlParserImplTinyXML2::init()
{
}

void E57XmlParserImplTinyXML2::parse( ImageFileImplSharedPtr imf, E57XmlInputSource &inputSource )
{
   imf_ = std::move( imf );

   std::string buffer( inputSource.length(), ' ' );
   if ( inputSource.readBytes( (unsigned char *)buffer.data(), buffer.size() ) != buffer.size() )
   {
      throw E57_EXCEPTION2( ErrorXMLParser, "failed to read input data" );
   }
   if ( xmlDocument_.Parse( buffer.data(), buffer.size() ) != XML_SUCCESS )
   {
      throw E57_EXCEPTION2( ErrorXMLParser,
                            "errorID=" + toString( xmlDocument_.ErrorID() ) + " errorString=\"" +
                               xmlDocument_.ErrorStr() +
                               "\" line=" + toString( xmlDocument_.ErrorLineNum() ) );
   }

   xmlDocument_.Accept( this );
}

ustring E57XmlParserImplTinyXML2::getContext() const
{
   return "fileName=" + imf_->fileName() + " qName=" + curElem_;
}

bool E57XmlParserImplTinyXML2::VisitEnter( const XMLElement &element,
                                           const XMLAttribute *attributes )
{
   curElem_ = element.Name();

   // find namespace declarations
   for ( const auto *attr = attributes; attr != NULL; attr = attr->Next() )
   {
      const auto name = ustring( attr->Name() );
      if ( name == "xmlns" )
      {
         E57XmlParserImpl::startNamespace_( "", attr->Value() );
      }
      else if ( name.substr( 0, 6 ) == "xmlns:" )
      {
         E57XmlParserImpl::startNamespace_( name.substr( 6 ), attr->Value() );
      }
   }

   const AttributeMapImplTinyXML2 attrMap( attributes );
   E57XmlParserImpl::startElement_( element.Name(), attrMap );
   return true;
}

bool E57XmlParserImplTinyXML2::VisitExit( const XMLElement &element )
{
   curElem_ = element.Name();
   E57XmlParserImpl::endElement_( element.Name() );
   return true;
}

bool E57XmlParserImplTinyXML2::Visit( const XMLText &text )
{
   E57XmlParserImpl::characters_( text.Value() );
   return true;
}

//=============================================================================
// E57XmlParserImpl

std::unique_ptr<E57XmlParserImpl> E57XmlParserImpl::create()
{
   return std::make_unique<E57XmlParserImplTinyXML2>();
}
