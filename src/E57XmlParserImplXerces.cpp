/*
 * Original work Copyright 2009 - 2010 Kevin Ackley (kackley@gwi.net)
 * Modified work Copyright 2018 - 2020 Andy Maloney <asmaloney@gmail.com>
 *
 * Permission is hereby granted, free of charge, to any person or organization
 * obtaining a copy of the software and accompanying documentation covered by
 * this license (the "Software") to use, reproduce, display, distribute,
 * execute, and transmit the Software, and to prepare derivative works of the
 * Software, and to permit third-parties to whom the Software is furnished to
 * do so, all subject to the following:
 *
 * The copyright notices in the Software and this entire statement, including
 * the above license grant, this restriction and the following disclaimer,
 * must be included in all copies of the Software, in whole or in part, and
 * all derivative works of the Software, unless such copies or derivative
 * works are solely in the form of machine-executable object code generated by
 * a source language processor.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
 * SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
 * FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 */

#include <xercesc/sax/InputSource.hpp>

#include <xercesc/sax2/Attributes.hpp>
#include <xercesc/sax2/DefaultHandler.hpp>
#include <xercesc/sax2/XMLReaderFactory.hpp>

#include <xercesc/util/BinInputStream.hpp>
#include <xercesc/util/TransService.hpp>

#include "E57XmlParser.h"
#include "ImageFileImpl.h"
#include "StringFunctions.h"

using namespace e57;
using namespace XERCES_CPP_NAMESPACE;

using xmlstring = std::basic_string<XMLCh>;

namespace
{
   ustring toUString( const XMLCh *const xml_str, XMLSize_t length = 0 )
   {
      ustring u_str;
      if ( ( xml_str != nullptr ) && *xml_str )
      {
         auto UTF8Transcoder = ( length == 0 ) ? TranscodeToStr( xml_str, "UTF-8" )
                                               : TranscodeToStr( xml_str, length, "UTF-8" );
         u_str = ustring( reinterpret_cast<const char *>( UTF8Transcoder.str() ),
                          UTF8Transcoder.length() );
      }
      return ( u_str );
   }

   xmlstring toXMLString( const char *const u_str, size_t length = 0 )
   {
      xmlstring xml_str;
      if ( ( u_str != nullptr ) && *u_str )
      {
         if ( length == 0 )
         {
            length = XMLString::stringLen( u_str );
         }
         auto UTF8Transcoder = TranscodeFromStr( (const XMLByte *)u_str, length, "UTF-8" );
         xml_str = xmlstring( UTF8Transcoder.str(), UTF8Transcoder.length() );
      }
      return ( xml_str );
   }
}

static_assert( std::is_same<size_t, XMLSize_t>::value,
               "size_t and XMLSize_t should be the same type" );

//=============================================================================
// XercesBinInputStream

class XercesBinInputStream final : public BinInputStream
{
public:
   XercesBinInputStream( E57XmlInputSource &inputSource ) : inputSource_( inputSource )
   {
   }
   ~XercesBinInputStream() override = default;

   XercesBinInputStream( const XercesBinInputStream & ) = delete;
   XercesBinInputStream &operator=( const XercesBinInputStream & ) = delete;

   XMLFilePos curPos() const override
   {
      return inputSource_.curPos();
   }

   XMLSize_t readBytes( XMLByte *toFill, XMLSize_t maxToRead ) override
   {
      return inputSource_.readBytes( toFill, maxToRead );
   }

   const XMLCh *getContentType() const override
   {
      return nullptr;
   }

private:
   E57XmlInputSource &inputSource_;
};

//=============================================================================
// XercesInputSource

class XercesInputSource final : public InputSource
{
public:
   XercesInputSource( E57XmlInputSource &inputSource ) :
      InputSource( "E57File",
                   XMLPlatformUtils::fgMemoryManager ), //??? what if want to use our own memory
                                                        // manager?, what bufid is good?
      inputSource_( inputSource )
   {
   }
   ~XercesInputSource() override = default;

   XercesInputSource( const XercesInputSource & ) = delete;
   XercesInputSource &operator=( const XercesInputSource & ) = delete;

   BinInputStream *makeStream() const override
   {
      return new XercesBinInputStream( inputSource_ );
   }

private:
   E57XmlInputSource &inputSource_;
};

//=============================================================================
// E57XmlParserImpl::AttributeMap

class AttributeMapImplXerces : public E57XmlParserImpl::AttributeMap
{
public:
   AttributeMapImplXerces( const Attributes &attributes );
   ~AttributeMapImplXerces() override = default;

   bool contains( const ustring &name ) const override;
   ustring lookup( const ustring &name ) const override;

private:
   const Attributes &attributes_;
};

AttributeMapImplXerces::AttributeMapImplXerces( const Attributes &attributes ) :
   attributes_( attributes )
{
}

bool AttributeMapImplXerces::contains( const ustring &name ) const
{
   const auto xmlName = toXMLString( name.c_str(), name.size() );
   XMLSize_t attr_index;
   return ( attributes_.getIndex( xmlName.c_str(), attr_index ) );
}

ustring AttributeMapImplXerces::lookup( const ustring &name ) const
{
   const auto xmlName = toXMLString( name.c_str(), name.size() );
   XMLSize_t attr_index;
   if ( !attributes_.getIndex( xmlName.c_str(), attr_index ) )
   {
      throw E57_EXCEPTION2( ErrorBadXMLFormat, "attributeName=" + name );
   }
   return ( toUString( attributes_.getValue( attr_index ) ) );
}

//=============================================================================
// E57XmlParserImplXerces

class E57XmlParserImplXerces final : public E57XmlParserImpl, public DefaultHandler
{
public:
   ~E57XmlParserImplXerces() override;

   void init() override;

   void parse( ImageFileImplSharedPtr imf, E57XmlInputSource &inputSource ) override;

protected:
   ustring getContext() const override;

private:
   /// SAX interface
   void startPrefixMapping( const XMLCh *prefix, const XMLCh *uri ) override;
   void startElement( const XMLCh *uri, const XMLCh *localName, const XMLCh *qName,
                      const Attributes &attributes ) override;
   void endElement( const XMLCh *uri, const XMLCh *localName, const XMLCh *qName ) override;
   void characters( const XMLCh *chars, XMLSize_t length ) override;

   /// SAX error interface
   void warning( const SAXParseException &ex ) override;
   void error( const SAXParseException &ex ) override;
   void fatalError( const SAXParseException &ex ) override;

   SAX2XMLReader *xmlReader{ nullptr };

   struct
   {
      const XMLCh *uri{ nullptr };
      const XMLCh *localName{ nullptr };
      const XMLCh *qName{ nullptr };
   } context_;
};

E57XmlParserImplXerces::~E57XmlParserImplXerces()
{
   delete xmlReader;

   xmlReader = nullptr;

   XMLPlatformUtils::Terminate();
}

void E57XmlParserImplXerces::init()
{
   // Initialize the XML4C2 system
   try
   {
      // NOTE: This is not thread safe for multiple simultaneous E57 readers.
      //       Ideally we'd do this once, not once per reader.
      XMLPlatformUtils::Initialize();
   }
   catch ( const XMLException &ex )
   {
      // Turn parser exception into E57Exception
      throw E57_EXCEPTION2( ErrorXMLParserInit,
                            "parserMessage=" + ustring( XMLString::transcode( ex.getMessage() ) ) );
   }

   xmlReader = XMLReaderFactory::createXMLReader(); //??? auto_ptr?

   if ( xmlReader == nullptr )
   {
      throw E57_EXCEPTION2( ErrorXMLParserInit, "could not create the xml reader" );
   }

   //??? check these are right
   xmlReader->setFeature( XMLUni::fgSAX2CoreValidation, true );
   xmlReader->setFeature( XMLUni::fgXercesDynamic, true );
   xmlReader->setFeature( XMLUni::fgSAX2CoreNameSpaces, true );
   xmlReader->setFeature( XMLUni::fgXercesSchema, true );
   xmlReader->setFeature( XMLUni::fgXercesSchemaFullChecking, true );
   xmlReader->setFeature( XMLUni::fgSAX2CoreNameSpacePrefixes, true );

   xmlReader->setContentHandler( this );
   xmlReader->setErrorHandler( this );
}

void E57XmlParserImplXerces::parse( ImageFileImplSharedPtr imf, E57XmlInputSource &inputSource )
{
   imf_ = std::move( imf );

   XercesInputSource xercesInputSource( inputSource );
   xmlReader->parse( xercesInputSource );
}

ustring E57XmlParserImplXerces::getContext() const
{
   return "fileName=" + imf_->fileName() + " uri=" + toUString( context_.uri ) +
          " localName=" + toUString( context_.localName ) + " qName=" + toUString( context_.qName );
}

void E57XmlParserImplXerces::startPrefixMapping( const XMLCh *prefix, const XMLCh *uri )
{
#ifdef E57_VERBOSE
   std::cout << "declared namespace, prefix=" + prefix + " URI=" + uri << std::endl;
#endif

   const auto p = toUString( prefix );
   const auto u = toUString( uri );
   E57XmlParserImpl::startNamespace_( p, u );
}

void E57XmlParserImplXerces::startElement( const XMLCh *uri, const XMLCh *localName,
                                           const XMLCh *qName, const Attributes &attributes )
{
#ifdef E57_VERBOSE
   std::cout << "startElement" << std::endl;
   std::cout << space( 2 ) << "URI:       " << toUString( uri ) << std::endl;
   std::cout << space( 2 ) << "localName: " << toUString( localName ) << std::endl;
   std::cout << space( 2 ) << "qName:     " << toUString( qName ) << std::endl;

   for ( size_t i = 0; i < attributes.getLength(); i++ )
   {
      std::cout << space( 2 ) << "Attribute[" << i << "]" << std::endl;
      std::cout << space( 4 ) << "URI:       " << toUString( attributes.getURI( i ) ) << std::endl;
      std::cout << space( 4 ) << "localName: " << toUString( attributes.getLocalName( i ) )
                << std::endl;
      std::cout << space( 4 ) << "qName:     " << toUString( attributes.getQName( i ) )
                << std::endl;
      std::cout << space( 4 ) << "value:     " << toUString( attributes.getValue( i ) )
                << std::endl;
   }
#endif

   // store info for context
   context_ = { uri, localName, qName };

   AttributeMapImplXerces attrMap( attributes );
   E57XmlParserImpl::startElement_( toUString( qName ), attrMap );
}

void E57XmlParserImplXerces::endElement( const XMLCh *uri, const XMLCh *localName,
                                         const XMLCh *qName )
{
#ifdef E57_VERBOSE
   std::cout << "endElement" << std::endl;
#endif

   // store info for context
   context_ = { uri, localName, qName };

   E57XmlParserImpl::endElement_( toUString( qName ) );
}

void E57XmlParserImplXerces::characters( const XMLCh *chars, XMLSize_t length )
{
#ifdef E57_VERBOSE
   std::cout << "characters, chars=\"" << toUString( chars ) << "\" length=" << length << std::endl;
#endif

   const auto s = toUString( chars, length );
   E57XmlParserImpl::characters_( s );
}

void E57XmlParserImplXerces::warning( const SAXParseException &ex )
{
   // Don't take any action on warning from parser, just report
   std::cerr << "**** XML parser warning: " << ustring( XMLString::transcode( ex.getMessage() ) )
             << std::endl;
   std::cerr << "  Debug info:" << std::endl;
   std::cerr << "    systemId=" << XMLString::transcode( ex.getSystemId() ) << std::endl;
   std::cerr << ",   xmlLine=" << ex.getLineNumber() << std::endl;
   std::cerr << ",   xmlColumn=" << ex.getColumnNumber() << std::endl;
}

void E57XmlParserImplXerces::error( const SAXParseException &ex )
{
   throw E57_EXCEPTION2(
      ErrorXMLParser, "systemId=" + ustring( XMLString::transcode( ex.getSystemId() ) ) +
                         " xmlLine=" + toString( ex.getLineNumber() ) +
                         " xmlColumn=" + toString( ex.getColumnNumber() ) +
                         " parserMessage=" + ustring( XMLString::transcode( ex.getMessage() ) ) );
}

void E57XmlParserImplXerces::fatalError( const SAXParseException &ex )
{
   throw E57_EXCEPTION2(
      ErrorXMLParser, "systemId=" + ustring( XMLString::transcode( ex.getSystemId() ) ) +
                         " xmlLine=" + toString( ex.getLineNumber() ) +
                         " xmlColumn=" + toString( ex.getColumnNumber() ) +
                         " parserMessage=" + ustring( XMLString::transcode( ex.getMessage() ) ) );
}

//=============================================================================
// E57XmlParserImpl

std::unique_ptr<E57XmlParserImpl> E57XmlParserImpl::create()
{
   return std::make_unique<E57XmlParserImplXerces>();
}
