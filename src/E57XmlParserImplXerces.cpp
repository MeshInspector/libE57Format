/*
 * Original work Copyright 2009 - 2010 Kevin Ackley (kackley@gwi.net)
 * Modified work Copyright 2018 - 2020 Andy Maloney <asmaloney@gmail.com>
 *
 * Permission is hereby granted, free of charge, to any person or organization
 * obtaining a copy of the software and accompanying documentation covered by
 * this license (the "Software") to use, reproduce, display, distribute,
 * execute, and transmit the Software, and to prepare derivative works of the
 * Software, and to permit third-parties to whom the Software is furnished to
 * do so, all subject to the following:
 *
 * The copyright notices in the Software and this entire statement, including
 * the above license grant, this restriction and the following disclaimer,
 * must be included in all copies of the Software, in whole or in part, and
 * all derivative works of the Software, unless such copies or derivative
 * works are solely in the form of machine-executable object code generated by
 * a source language processor.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
 * SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
 * FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 */

#include <xercesc/sax/InputSource.hpp>

#include <xercesc/sax2/Attributes.hpp>
#include <xercesc/sax2/DefaultHandler.hpp>
#include <xercesc/sax2/XMLReaderFactory.hpp>

#include <xercesc/util/BinInputStream.hpp>
#include <xercesc/util/TransService.hpp>

#include "E57XmlParser.h"
#include "ImageFileImpl.h"
#include "StringFunctions.h"

using namespace e57;
using namespace XERCES_CPP_NAMESPACE;

using xmlstring = std::basic_string<XMLCh>;

namespace
{
   ustring toUString( const XMLCh *const xml_str, XMLSize_t length = 0 )
   {
      ustring u_str;
      if ( ( xml_str != nullptr ) && *xml_str )
      {
         if ( length == 0 )
         {
            length = XMLString::stringLen( xml_str );
         }
         TranscodeToStr UTF8Transcoder( xml_str, length, "UTF-8" );
         u_str = ustring( reinterpret_cast<const char *>( UTF8Transcoder.str() ),
                          UTF8Transcoder.length() );
      }
      return ( u_str );
   }

   xmlstring toXMLString( const char *const u_str, size_t length = 0 )
   {
      xmlstring xml_str;
      if ( ( u_str != nullptr ) && *u_str )
      {
         if ( length == 0 )
         {
            length = XMLString::stringLen( u_str );
         }
         TranscodeFromStr UTF8Transcoder( (const XMLByte *)u_str, length, "UTF-8" );
         xml_str = xmlstring( UTF8Transcoder.str(), UTF8Transcoder.length() );
      }
      return ( xml_str );
   }
}

static_assert( std::is_same<size_t, XMLSize_t>::value,
               "size_t and XMLSize_t should be the same type" );

//=============================================================================
// XercesBinInputStream

class XercesBinInputStream final : public BinInputStream
{
public:
   XercesBinInputStream( E57XmlInputSource &inputSource ) : inputSource_( inputSource )
   {
   }
   ~XercesBinInputStream() override = default;

   XercesBinInputStream( const XercesBinInputStream & ) = delete;
   XercesBinInputStream &operator=( const XercesBinInputStream & ) = delete;

   XMLFilePos curPos() const override
   {
      return inputSource_.curPos();
   }

   XMLSize_t readBytes( XMLByte *toFill, XMLSize_t maxToRead ) override
   {
      return inputSource_.readBytes( toFill, maxToRead );
   }

   const XMLCh *getContentType() const override
   {
      return nullptr;
   }

private:
   E57XmlInputSource &inputSource_;
};

//=============================================================================
// XercesInputSource

class XercesInputSource final : public InputSource
{
public:
   XercesInputSource( E57XmlInputSource &inputSource ) :
      InputSource( "E57File",
                   XMLPlatformUtils::fgMemoryManager ), //??? what if want to use our own memory
                                                        // manager?, what bufid is good?
      inputSource_( inputSource )
   {
   }
   ~XercesInputSource() override = default;

   XercesInputSource( const XercesInputSource & ) = delete;
   XercesInputSource &operator=( const XercesInputSource & ) = delete;

   BinInputStream *makeStream() const override
   {
      return new XercesBinInputStream( inputSource_ );
   }

private:
   E57XmlInputSource &inputSource_;
};

//=============================================================================
// E57XmlProcessor::AttributeMap

class AttributeMap : public E57XmlProcessor::AttributeMap
{
public:
   AttributeMap( const Attributes &attributes );
   ~AttributeMap() override = default;

   size_t length() const override;
   ustring getQName( size_t index ) const override;
   ustring getValue( size_t index ) const override;

   bool contains( const ustring &name ) const override;
   ustring lookup( const ustring &name ) const override;

private:
   const Attributes &attributes_;
};

AttributeMap::AttributeMap( const Attributes &attributes ) : attributes_( attributes )
{
}

size_t AttributeMap::length() const
{
   return attributes_.getLength();
}

ustring AttributeMap::getQName( size_t index ) const
{
   return toUString( attributes_.getQName( index ) );
}

ustring AttributeMap::getValue( size_t index ) const
{
   return toUString( attributes_.getValue( index ) );
}

bool AttributeMap::contains( const ustring &name ) const
{
   const auto xmlName = toXMLString( name.c_str(), name.size() );
   XMLSize_t attr_index;
   return ( attributes_.getIndex( xmlName.c_str(), attr_index ) );
}

ustring AttributeMap::lookup( const ustring &name ) const
{
   const auto xmlName = toXMLString( name.c_str(), name.size() );
   XMLSize_t attr_index;
   if ( !attributes_.getIndex( xmlName.c_str(), attr_index ) )
   {
      throw E57_EXCEPTION2( ErrorBadXMLFormat, "attributeName=" + name );
   }
   return ( toUString( attributes_.getValue( attr_index ) ) );
}

//=============================================================================
// E57XmlParserImpl

class Parser final : public E57XmlParserImpl, public DefaultHandler
{
public:
   ~Parser() override;

   void init() override;

   void parse( E57XmlInputSource &inputSource, E57XmlProcessor &processor ) override;

private:
   /// SAX interface
   void startPrefixMapping( const XMLCh *prefix, const XMLCh *uri ) override;
   void startElement( const XMLCh *uri, const XMLCh *localName, const XMLCh *qName,
                      const Attributes &attributes ) override;
   void endElement( const XMLCh *uri, const XMLCh *localName, const XMLCh *qName ) override;
   void characters( const XMLCh *chars, XMLSize_t length ) override;

   /// SAX error interface
   void warning( const SAXParseException &ex ) override;
   void error( const SAXParseException &ex ) override;
   void fatalError( const SAXParseException &ex ) override;

   SAX2XMLReader *xmlReader{ nullptr };
   E57XmlProcessor *processor_{ nullptr };
};

Parser::~Parser()
{
   delete xmlReader;

   xmlReader = nullptr;

   XMLPlatformUtils::Terminate();
}

void Parser::init()
{
   // Initialize the XML4C2 system
   try
   {
      // NOTE: This is not thread safe for multiple simultaneous E57 readers.
      //       Ideally we'd do this once, not once per reader.
      XMLPlatformUtils::Initialize();
   }
   catch ( const XMLException &ex )
   {
      // Turn parser exception into E57Exception
      throw E57_EXCEPTION2( ErrorXMLParserInit,
                            "parserMessage=" + ustring( XMLString::transcode( ex.getMessage() ) ) );
   }

   xmlReader = XMLReaderFactory::createXMLReader(); //??? auto_ptr?

   if ( xmlReader == nullptr )
   {
      throw E57_EXCEPTION2( ErrorXMLParserInit, "could not create the xml reader" );
   }

   //??? check these are right
   xmlReader->setFeature( XMLUni::fgSAX2CoreValidation, true );
   xmlReader->setFeature( XMLUni::fgXercesDynamic, true );
   xmlReader->setFeature( XMLUni::fgSAX2CoreNameSpaces, true );
   xmlReader->setFeature( XMLUni::fgXercesSchema, true );
   xmlReader->setFeature( XMLUni::fgXercesSchemaFullChecking, true );
   xmlReader->setFeature( XMLUni::fgSAX2CoreNameSpacePrefixes, true );

   xmlReader->setContentHandler( this );
   xmlReader->setErrorHandler( this );
}

void Parser::parse( E57XmlInputSource &inputSource, E57XmlProcessor &processor )
{
   processor_ = &processor;
   XercesInputSource xercesInputSource( inputSource );
   xmlReader->parse( xercesInputSource );
}

void Parser::startPrefixMapping( const XMLCh *prefix, const XMLCh *uri )
{
   processor_->startNamespace( toUString( prefix ), toUString( uri ) );
}

void Parser::startElement( const XMLCh *uri, const XMLCh *localName, const XMLCh *qName,
                           const Attributes &attributes )
{
   E57_UNUSED( uri );
   E57_UNUSED( localName );
   AttributeMap attrMap( attributes );
   processor_->startElement( toUString( qName ), attrMap );
}

void Parser::endElement( const XMLCh *uri, const XMLCh *localName, const XMLCh *qName )
{
   E57_UNUSED( uri );
   E57_UNUSED( localName );
   processor_->endElement( toUString( qName ) );
}

void Parser::characters( const XMLCh *chars, XMLSize_t length )
{
   processor_->text( toUString( chars, length ) );
}

void Parser::warning( const SAXParseException &ex )
{
   // Don't take any action on warning from parser, just report
   std::cerr << "**** XML parser warning: " << ustring( XMLString::transcode( ex.getMessage() ) )
             << std::endl;
   std::cerr << "  Debug info:" << std::endl;
   std::cerr << "    systemId=" << XMLString::transcode( ex.getSystemId() ) << std::endl;
   std::cerr << ",   xmlLine=" << ex.getLineNumber() << std::endl;
   std::cerr << ",   xmlColumn=" << ex.getColumnNumber() << std::endl;
}

void Parser::error( const SAXParseException &ex )
{
   throw E57_EXCEPTION2(
      ErrorXMLParser, "systemId=" + ustring( XMLString::transcode( ex.getSystemId() ) ) +
                         " xmlLine=" + toString( ex.getLineNumber() ) +
                         " xmlColumn=" + toString( ex.getColumnNumber() ) +
                         " parserMessage=" + ustring( XMLString::transcode( ex.getMessage() ) ) );
}

void Parser::fatalError( const SAXParseException &ex )
{
   throw E57_EXCEPTION2(
      ErrorXMLParser, "systemId=" + ustring( XMLString::transcode( ex.getSystemId() ) ) +
                         " xmlLine=" + toString( ex.getLineNumber() ) +
                         " xmlColumn=" + toString( ex.getColumnNumber() ) +
                         " parserMessage=" + ustring( XMLString::transcode( ex.getMessage() ) ) );
}

//=============================================================================
// E57XmlParserImpl

std::unique_ptr<E57XmlParserImpl> E57XmlParserImpl::create()
{
   return std::make_unique<Parser>();
}
